\hypertarget{functions_8hpp}{}\doxysection{D\+:/\+Academics/\+S\+E\+M6/\+D\+AA CS F364/\+D\+A\+A-\/\+Assignments/\+Assignment-\/2/functions.hpp File Reference}
\label{functions_8hpp}\index{D:/Academics/SEM6/DAA CS F364/DAA-\/Assignments/Assignment-\/2/functions.hpp@{D:/Academics/SEM6/DAA CS F364/DAA-\/Assignments/Assignment-\/2/functions.hpp}}
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include \char`\"{}line.\+hpp\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$ \mbox{\hyperlink{functions_8hpp_a4bada49d62a5f3501c40489f8f0c4449}{slice}} (int i, int j, vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$ P)
\begin{DoxyCompactList}\small\item\em Slices out indices from {\itshape i} to {\itshape j} from the vector of points {\itshape P}. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{functions_8hpp_a8856ac4625304f2e0694756b6b3a1388}{cal\+\_\+err}} (vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$ P)
\begin{DoxyCompactList}\small\item\em Gives the cumulative error of the calculated line for the given point set, \mbox{\hyperlink{class_line}{Line}} is calculated by the normal formula. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{functions_8hpp_a435c407726d7d0e473db05da3dd48e70}{O\+PT}} (int j, double cost, vector$<$ double $>$ \&M, vector$<$ vector$<$ double $>$$>$ Err)
\begin{DoxyCompactList}\small\item\em It is the recursive function which calculates the penalty at each index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{functions_8hpp_a391697f03638c13638f88f256eaf9c84}{Segmented\+\_\+\+Least\+\_\+\+Square}} (vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$ P, double cost, vector$<$ double $>$ \&M, vector$<$ vector$<$ double $>$$>$ \&Err)
\begin{DoxyCompactList}\small\item\em Driver function for {\itshape O\+PT} and also calculates error for all possible (start, end) pairs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{functions_8hpp_af06ca17158088f2a7adc353ecaf02ceb}{Find\+\_\+\+Segment}} (int j, vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$ P, vector$<$ double $>$ M, double cost, vector$<$ vector$<$ double $>$$>$ Err, vector$<$ vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$$>$ \&result)
\begin{DoxyCompactList}\small\item\em recursively finds the best possible partitions of points, given {\itshape M} penalty at each index, {\itshape P} input point set, {\itshape Err} error for all possible segments of points \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header file for including functions required to find the segments for given set of input points

\begin{DoxyAuthor}{Authors}
Kumar Pranjal 2018A7\+P\+S0163H 

Ashna Swaika 2018A7\+P\+S0027H 

Abhishek Bapna 2018A7\+P\+S0184H 

Ashish Verma 2018A7\+P\+S0009H 
\end{DoxyAuthor}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{functions_8hpp_a8856ac4625304f2e0694756b6b3a1388}\label{functions_8hpp_a8856ac4625304f2e0694756b6b3a1388}} 
\index{functions.hpp@{functions.hpp}!cal\_err@{cal\_err}}
\index{cal\_err@{cal\_err}!functions.hpp@{functions.hpp}}
\doxysubsubsection{\texorpdfstring{cal\_err()}{cal\_err()}}
{\footnotesize\ttfamily double cal\+\_\+err (\begin{DoxyParamCaption}\item[{vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$}]{P }\end{DoxyParamCaption})}



Gives the cumulative error of the calculated line for the given point set, \mbox{\hyperlink{class_line}{Line}} is calculated by the normal formula. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & vector of Points \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\itshape error} 
\end{DoxyReturn}
\mbox{\Hypertarget{functions_8hpp_af06ca17158088f2a7adc353ecaf02ceb}\label{functions_8hpp_af06ca17158088f2a7adc353ecaf02ceb}} 
\index{functions.hpp@{functions.hpp}!Find\_Segment@{Find\_Segment}}
\index{Find\_Segment@{Find\_Segment}!functions.hpp@{functions.hpp}}
\doxysubsubsection{\texorpdfstring{Find\_Segment()}{Find\_Segment()}}
{\footnotesize\ttfamily void Find\+\_\+\+Segment (\begin{DoxyParamCaption}\item[{int}]{j,  }\item[{vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$}]{P,  }\item[{vector$<$ double $>$}]{M,  }\item[{double}]{cost,  }\item[{vector$<$ vector$<$ double $>$$>$}]{Err,  }\item[{vector$<$ vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$$>$ \&}]{result }\end{DoxyParamCaption})}



recursively finds the best possible partitions of points, given {\itshape M} penalty at each index, {\itshape P} input point set, {\itshape Err} error for all possible segments of points 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em j} & integer, partitions have to be found for elements lying before this index \\
\hline
\mbox{\texttt{ in}}  & {\em P} & vector of points, given input \\
\hline
\mbox{\texttt{ in}}  & {\em M} & vector of double, stores the penalty of every index \\
\hline
\mbox{\texttt{ in}}  & {\em cost} & double, constant cost \\
\hline
\mbox{\texttt{ in}}  & {\em Err} & vector of vector of double, stores the error values corresponding to every ( {\itshape i}, {\itshape j} ) pairs \\
\hline
\mbox{\texttt{ out}}  & {\em result} & vector of vector of points, gives the final optimal partitions for the set of points \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\itshape result} gives a vector of partitions where each partition is a vector of points belonging to the same partition. 
\end{DoxyNote}
\mbox{\Hypertarget{functions_8hpp_a435c407726d7d0e473db05da3dd48e70}\label{functions_8hpp_a435c407726d7d0e473db05da3dd48e70}} 
\index{functions.hpp@{functions.hpp}!OPT@{OPT}}
\index{OPT@{OPT}!functions.hpp@{functions.hpp}}
\doxysubsubsection{\texorpdfstring{OPT()}{OPT()}}
{\footnotesize\ttfamily void O\+PT (\begin{DoxyParamCaption}\item[{int}]{j,  }\item[{double}]{cost,  }\item[{vector$<$ double $>$ \&}]{M,  }\item[{vector$<$ vector$<$ double $>$$>$}]{Err }\end{DoxyParamCaption})}



It is the recursive function which calculates the penalty at each index. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em j} & integer, gives the index for which we wish to find penalty \\
\hline
\mbox{\texttt{ in}}  & {\em cost} & integer constant \\
\hline
\mbox{\texttt{ out}}  & {\em M} & vector of double which calculates minimum penalty at any given index \\
\hline
\mbox{\texttt{ in}}  & {\em Err} & vector of vector of double, gives the error for different segments \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\itshape M} is given as the output, that is, it is calculated for index {\itshape j} 
\end{DoxyNote}
\mbox{\Hypertarget{functions_8hpp_a391697f03638c13638f88f256eaf9c84}\label{functions_8hpp_a391697f03638c13638f88f256eaf9c84}} 
\index{functions.hpp@{functions.hpp}!Segmented\_Least\_Square@{Segmented\_Least\_Square}}
\index{Segmented\_Least\_Square@{Segmented\_Least\_Square}!functions.hpp@{functions.hpp}}
\doxysubsubsection{\texorpdfstring{Segmented\_Least\_Square()}{Segmented\_Least\_Square()}}
{\footnotesize\ttfamily void Segmented\+\_\+\+Least\+\_\+\+Square (\begin{DoxyParamCaption}\item[{vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$}]{P,  }\item[{double}]{cost,  }\item[{vector$<$ double $>$ \&}]{M,  }\item[{vector$<$ vector$<$ double $>$$>$ \&}]{Err }\end{DoxyParamCaption})}



Driver function for {\itshape O\+PT} and also calculates error for all possible (start, end) pairs. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & vector of points, given input \\
\hline
\mbox{\texttt{ in}}  & {\em cost} & double, constant cost \\
\hline
\mbox{\texttt{ out}}  & {\em M} & vector of double, stores the penalty of every index \\
\hline
\mbox{\texttt{ out}}  & {\em Err} & vector of vector of double, stores the error values corresponding to every ( {\itshape i}, {\itshape j} ) pairs \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
{\itshape M} and {\itshape Err} are the outputs for the functions. Err\mbox{[}i\mbox{]}\mbox{[}j\mbox{]} for any given i and j refers to the error a segment starting from point on i-\/th index upto point on (i+j+1)-\/th index gets. 
\end{DoxyNote}
\mbox{\Hypertarget{functions_8hpp_a4bada49d62a5f3501c40489f8f0c4449}\label{functions_8hpp_a4bada49d62a5f3501c40489f8f0c4449}} 
\index{functions.hpp@{functions.hpp}!slice@{slice}}
\index{slice@{slice}!functions.hpp@{functions.hpp}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}}
{\footnotesize\ttfamily vector$<$\mbox{\hyperlink{class_point}{Point}}$>$ slice (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j,  }\item[{vector$<$ \mbox{\hyperlink{class_point}{Point}} $>$}]{P }\end{DoxyParamCaption})}



Slices out indices from {\itshape i} to {\itshape j} from the vector of points {\itshape P}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i} & integer, starting index \\
\hline
\mbox{\texttt{ in}}  & {\em j} & integer, ending index \\
\hline
\mbox{\texttt{ in}}  & {\em P} & vector of points, the array from where {\itshape i} to {\itshape j} elements will be sliced from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\itshape result} vector of points, the sliced out vector of points 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
the original vector {\itshape P} remains unchanged during this process 
\end{DoxyNote}
